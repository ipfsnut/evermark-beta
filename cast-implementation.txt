# Farcaster Cast Evermarks Implementation Plan

## Problem Analysis

### Current Issues
1. **Missing API Endpoint**: `FarcasterService.fetchCastMetadata()` calls non-existent `/.netlify/functions/farcaster-cast`
2. **No Cast Metadata Fetching**: Creation flow in `useEvermarkCreation.ts` doesn't fetch cast data during creation
3. **Broken Cast Images**: `generate-cast-image.ts` fails because cast metadata is missing from database
4. **Inconsistent Data**: Cast #3 has rich metadata, but #4-5 only have minimal data

### What Works
- Neynar API integration (API key available: in .env.local)
- Cast validation in `FarcasterService.validateFarcasterInput()`
- Cast image generation logic (when metadata is available)
- Cast #3 shows proper metadata structure and image generation

---

## Architecture Plan

### Phase 1: Create Missing API Endpoint
**File**: `netlify/functions/farcaster-cast.ts`

```typescript
// New endpoint to fetch cast metadata from Neynar API
// GET /.netlify/functions/farcaster-cast?hash={castHash}
// Returns: FarcasterCastData structure
```

**Responsibilities**:
- Extract cast hash from query parameters
- Validate hash format
- Call Neynar API with proper authentication
- Transform Neynar response to our `FarcasterCastData` interface
- Handle rate limits and errors gracefully
- Return consistent data structure

### Phase 2: Integrate Cast Metadata Fetching in Creation Flow
**File**: `src/features/evermarks/hooks/useEvermarkCreation.ts`

**Current Flow**:
```
1. Validate inputs
2. Upload image to IPFS
3. Create NFT metadata
4. Mint on blockchain
5. Sync to database
```

**New Flow**:
```
1. Validate inputs
2. [NEW] If contentType === 'Cast': Fetch cast metadata via FarcasterService
3. Upload image to IPFS
4. Create NFT metadata (include cast data)
5. Mint on blockchain
6. Sync to database (include rich cast metadata)
```

**Integration Point**: Line 162-214 where NFT metadata is created

### Phase 3: Enhance Cast Image Generation with Modern Design
**File**: `netlify/functions/generate-cast-image.ts`

**Current Issues**:
- Basic text-only display with dated styling
- Relies on cast data being in `metadata_json`  
- Falls back to empty defaults when data is missing
- Not automatically triggered for new casts

**Visual Improvements**:
- **Profile Pictures**: Circular profile image from author's pfp_url
- **Better Typography**: Improved fonts, spacing, and hierarchy
- **Channel Context**: Show channel name/badge if cast belongs to a channel
- **Embed Indicators**: Show icons for images, links, or other media
- **Modern Design**: Updated color scheme, shadows, and layout
- **Responsive Layout**: Better text wrapping and content flow

**Technical Improvements**:
- Better error handling when cast data is missing
- Automatic image generation after cast creation
- Profile picture downloading and caching
- Support for different cast types (text, with embeds, etc.)
- Retry mechanism for failed generations

### Phase 4: Fix Existing Broken Casts
**Strategy**: Create migration/repair function
- Identify cast evermarks with minimal metadata (casts #4, #5)
- Re-fetch their cast data from Neynar API
- Update database records with rich metadata
- Regenerate cast preview images

---

## Detailed Implementation

### 1. Netlify Function: `farcaster-cast.ts`

```typescript
interface NeynarCastResponse {
  cast: {
    hash: string;
    author: {
      username: string;
      display_name: string;
      pfp_url: string;
      fid: number;
    };
    text: string;
    timestamp: string;
    reactions: {
      likes_count: number;
      recasts_count: number;
    };
    replies: {
      count: number;
    };
  };
}

// Transform to our FarcasterCastData interface
```

**Error Handling**:
- Invalid hash format
- Cast not found on Neynar
- API rate limits
- Network errors

**Caching Strategy**:
- Cache successful responses for 1 hour
- Use cast hash as cache key

### 2. Creation Flow Integration

**In `createEvermarkWithBlockchain()`**:

```typescript
// After line 162 (metadata validation)
let castData: FarcasterCastData | undefined;

if (metadata.contentType === 'Cast') {
  const castInput = metadata.sourceUrl || metadata.castUrl;
  if (castInput) {
    try {
      onProgress(30, 'Fetching Farcaster cast data...');
      castData = await FarcasterService.fetchCastMetadata(castInput);
    } catch (error) {
      console.warn('Cast metadata fetch failed:', error);
      // Continue creation without cast data (graceful degradation)
    }
  }
}

// Update NFT metadata creation (line 175-214)
const nftMetadata = {
  // ... existing fields ...
  evermark: {
    // ... existing fields ...
    castData, // Add cast data
    castUrl: metadata.sourceUrl || metadata.castUrl,
  }
};

// Update database sync (line 285-296)
metadata: JSON.stringify({
  // ... existing fields ...
  cast: castData, // Add cast data for image generation
}),
```

### 3. Database Schema Considerations

**Current `metadata_json` structure for working cast**:
```json
{
  "cast": {
    "text": "...",
    "author_username": "...", 
    "author_display_name": "...",
    "likes": 32,
    "recasts": 5,
    "replies": 16,
    "timestamp": "...",
    "hash": "..."
  },
  "tags": ["farcaster", "cast"],
  "customFields": [...]
}
```

**Ensure consistency** between:
- IPFS metadata (`evermark.castData`)
- Database metadata (`metadata_json.cast`)
- Custom fields backup

### 4. Automatic Image Generation

**Current**: Manual trigger via `generate-cast-image.ts`
**New**: Automatic trigger after cast creation

**Integration options**:
1. **In creation flow**: Call image generation after database sync
2. **Database trigger**: PostgreSQL function/trigger on insert
3. **Background job**: Queue-based processing

**Recommended**: Option 1 (simplest integration)

```typescript
// After database sync success (line 318)
if (castData && mintResult.tokenId) {
  try {
    onProgress(98, 'Generating cast preview image...');
    await fetch('/.netlify/functions/generate-cast-image', {
      method: 'POST',
      body: JSON.stringify({ token_id: mintResult.tokenId })
    });
  } catch {
    // Don't fail creation if image generation fails
  }
}
```

---

## Migration Plan for Broken Casts

### Repair Function: `netlify/functions/repair-cast-metadata.ts`

**Purpose**: Fix existing casts #4 and #5

**Logic**:
1. Query casts with `content_type = 'Cast'` and minimal metadata
2. Extract cast hash from `source_url`
3. Fetch metadata from Neynar API
4. Update `metadata_json` with rich cast data
5. Trigger image generation

**Manual trigger** for safety, then automate if needed

---

## Testing Strategy

### Unit Tests
- `FarcasterService.fetchCastMetadata()` with various inputs
- Cast hash extraction and validation
- Metadata transformation logic

### Integration Tests
- End-to-end cast creation flow
- Image generation with rich metadata
- Error handling (invalid hashes, API failures)

### Manual Testing
- Create new cast evermark with working cast hash
- Verify metadata is fetched and stored correctly
- Verify image generation works
- Test with various cast types (text only, with images, etc.)

---

## Rollout Plan

### Phase 1: Foundation (Day 1)
- [ ] Create `farcaster-cast.ts` netlify function
- [ ] Test with existing cast hashes
- [ ] Verify `FarcasterService.fetchCastMetadata()` works end-to-end

### Phase 2: Integration (Day 2)
- [ ] Integrate cast fetching into creation flow
- [ ] Test new cast creation with metadata fetching
- [ ] Ensure backward compatibility

### Phase 3: Image Generation (Day 3)
- [ ] Add automatic image generation after cast creation
- [ ] Test image generation with rich metadata
- [ ] Handle edge cases (missing data, API failures)

### Phase 4: Migration (Day 4)
- [ ] Create repair function for broken casts
- [ ] Fix casts #4 and #5
- [ ] Verify all cast evermarks have proper images

### Phase 5: Monitoring (Ongoing)
- [ ] Monitor cast creation success rates
- [ ] Track image generation success
- [ ] Monitor Neynar API usage and rates

---

## Risk Mitigation

### API Dependencies
- **Risk**: Neynar API downtime/rate limits
- **Mitigation**: Graceful degradation, retry logic, caching

### Data Consistency
- **Risk**: Mismatched metadata between IPFS and database
- **Mitigation**: Consistent data transformation, validation

### Performance
- **Risk**: Cast creation becomes slower
- **Mitigation**: Parallel operations, progress indicators

### Backward Compatibility
- **Risk**: Breaking existing cast evermarks
- **Mitigation**: Thorough testing, gradual rollout

---

## Success Metrics

- [ ] All new cast evermarks have rich metadata
- [ ] Cast preview images generate successfully
- [ ] Creation flow completes in <30 seconds
- [ ] Zero regression on existing functionality
- [ ] Casts #4 and #5 are repaired and functional

---

## Duplicate Content Prevention & Voting Redirection

### Problem
Currently, multiple users can mint the same cast/content, creating redundant Evermarks and fragmenting engagement.

### Solution: Frontend Duplicate Detection with Voting Redirection

#### Phase 1: API Enhancement
**File**: `netlify/functions/evermarks.ts`

Add duplicate check endpoint:
```typescript
// GET /api/evermarks?check_duplicate=true&source_url=...
// Returns: { exists: boolean, existingTokenId?: number, evermark?: EvermarkRecord }
```

**Implementation**:
- Query `beta_evermarks` table by `source_url` 
- Return existing token ID and metadata if found
- Include voting/engagement stats for decision making

#### Phase 2: Frontend Integration
**File**: `src/features/evermarks/hooks/useEvermarkCreation.ts`

**New Pre-Mint Flow**:
```typescript
1. Validate inputs
2. [NEW] Check for duplicate content via API
3. [NEW] If duplicate exists:
   - Show "Content Already Exists" modal
   - Offer options:
     a) "Vote on Existing Evermark" â†’ redirect to detail page
     b) "View Existing Evermark" â†’ open in new tab  
     c) "Create Anyway" â†’ continue with original flow
4. If no duplicate OR user chooses "Create Anyway":
   - Continue with normal creation flow
```

#### Phase 3: UI Components
**New Component**: `DuplicateContentModal.tsx`

**Features**:
- Show existing Evermark preview
- Display current vote counts/rankings
- Highlight voting benefits vs. duplicate creation
- Clear call-to-action buttons

**Integration Points**:
- `CreateEvermarkForm.tsx`: Trigger duplicate check before minting
- `EvermarkDetailPage.tsx`: Enhanced voting UI for redirected users

#### Phase 4: User Experience Flow

**Duplicate Detected Flow**:
```
User submits cast URL â†’ API finds existing Evermark #1234 â†’ Modal appears:

"ðŸŽ¯ This content is already preserved!"

[Preview of existing Evermark #1234]
â€¢ Created by @alice 3 days ago
â€¢ 15 votes, 0.5 ETH staked
â€¢ Ranked #47 on leaderboard

Instead of creating a duplicate:
[ðŸ—³ï¸ Vote & Boost Ranking] [ðŸ‘€ View Evermark] [âš¡ Create Anyway]
```

#### Benefits
- **Prevents Content Bloat**: Reduces redundant Evermarks
- **Drives Engagement**: Channels users to existing content
- **Promotes Voting**: Increases $EMARK staking and delegation
- **Better Discovery**: Users find existing high-quality content
- **Maintains Choice**: Advanced users can still force creation

#### Technical Implementation Notes
- Use `source_url` as primary duplicate detection field
- Consider fuzzy matching for slight URL variations (twitter.com vs x.com)
- Cache duplicate check results to avoid repeated API calls
- Implement client-side validation before API call when possible

---

## Open Questions

1. **Rate Limits**: What are Neynar API rate limits? Need caching strategy?
2. **Error UX**: How to handle cast-not-found errors in UI?
3. **Image Storage**: Continue using Supabase Storage for cast images?
4. **Metadata Version**: Should we version metadata schema for future changes?
5. **Bulk Migration**: Process for fixing other broken casts beyond #4-5?
6. **Duplicate Threshold**: How similar should URLs be to trigger duplicate detection?
7. **Voting Incentives**: Should duplicate creators get any benefit for discovering existing content?

---

This plan provides a comprehensive approach to fixing the Farcaster cast evermark system while adding intelligent duplicate prevention that drives engagement to existing content.