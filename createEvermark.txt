# EVERMARK CREATION FLOW DOCUMENTATION

## OVERVIEW
This document details the complete flow of creating an evermark, from UI interaction to blockchain minting and database storage.

## HIGH-LEVEL FLOW
1. User fills out creation form
2. Metadata uploaded to IPFS
3. Smart contract minted on Base blockchain
4. Database record created
5. Cast preview image generated (for Cast content)
6. Success confirmation shown

## DETAILED STEP-BY-STEP PROCESS

### PHASE 1: UI FORM INTERACTION
**File**: `src/features/evermarks/components/CreateEvermarkForm.tsx`

**User Actions**:
- Select content type (Custom, Cast, DOI, ISBN, URL)
- Enter title and description
- Paste source URL (triggers auto-detection for Cast URLs)
- Upload image (optional for Cast content)
- Add tags

**Key Functions**:
- `handleFieldChange()` - Handles form input changes
- `handleAutoDetect()` - Auto-detects and fetches Cast data from Farcaster URLs
- `generateCastImagePreview()` - Generates preview image for Cast content

**Cast-Specific Flow**:
1. User pastes Farcaster URL
2. `FarcasterService.fetchCastMetadata()` called via `/farcaster-cast` endpoint
3. Cast data populates form fields automatically
4. Cast preview image generated via `/generate-cast-image` endpoint
5. Preview shown in UI

### PHASE 2: FORM SUBMISSION
**File**: `src/features/evermarks/components/CreateEvermarkForm.tsx` -> `handleSubmit()`

**Validation**:
- Check if wallet connected (`hasWallet`)
- Validate form fields (`isFormValid()`)
- Check creation permissions (`canCreate`)

**Data Preparation**:
```typescript
const evermarkMetadata: EvermarkMetadata = {
  title: formData.title.trim(),
  description: formData.description.trim(),
  sourceUrl: formData.sourceUrl.trim(),
  author: getAuthor(),
  tags,
  contentType: formData.contentType,
  customFields: []
};

const createInput: CreateEvermarkInput = {
  metadata: evermarkMetadata,
  image: selectedImage || undefined
};
```

### PHASE 3: CREATION PROCESS
**File**: `src/features/evermarks/hooks/useEvermarkCreation.ts`

**Main Function**: `createEvermarkWithBlockchain()`

**Sub-processes**:

#### 3A: INPUT VALIDATION
```typescript
// Check wallet connection
if (!account?.address) throw new Error('No wallet connected');

// Check required fields
if (!input.metadata?.title) throw new Error('Title is required');

// Image is optional for Cast content type
if (!input.image && input.metadata?.contentType !== 'Cast') {
  throw new Error('Image is required for evermark creation');
}
```

#### 3B: METADATA FETCHING
For Cast content:
```typescript
if (metadata.contentType === 'Cast' && metadata.sourceUrl) {
  const { FarcasterService } = await import('../services/FarcasterService');
  castData = await FarcasterService.fetchCastMetadata(metadata.sourceUrl);
}
```

**Farcaster Service Flow**:
- **File**: `src/features/evermarks/services/FarcasterService.ts`
- **API Endpoint**: `netlify/functions/farcaster-cast.ts`
- **External API**: Neynar API for cast data
- **Returns**: Cast hash, author, content, engagement metrics, embeds

#### 3C: IMAGE UPLOAD TO IPFS
**Service**: `PinataService`
**File**: `src/services/PinataService.ts`

```typescript
if (input.image) {
  const imageUploadResult = await pinataService.uploadImage(input.image);
  // imageUploadResult.hash contains IPFS hash
} else if (metadata.contentType === 'Cast') {
  // Skip image upload for Cast content
  console.log('No manual image provided for Cast content');
}
```

#### 3D: NFT METADATA CREATION
```typescript
const nftMetadata = {
  name: metadata.title,
  description: metadata.description ?? '',
  image: imageUploadResult?.hash ? `ipfs://${imageUploadResult.hash}` : undefined,
  external_url: metadata.sourceUrl,
  attributes: [
    { trait_type: 'Content Type', value: metadata.contentType },
    { trait_type: 'Creator', value: castData?.author || metadata.author },
    { trait_type: 'Creation Date', value: new Date().toISOString() }
  ],
  evermark: {
    version: '1.0',
    contentType: metadata.contentType,
    sourceUrl: metadata.sourceUrl,
    tags: metadata.tags,
    customFields: metadata.customFields,
    // Cast-specific data
    ...(castData && {
      castData: {
        castHash: castData.castHash,
        author: castData.author,
        username: castData.username,
        content: castData.content,
        timestamp: castData.timestamp,
        engagement: castData.engagement
      }
    })
  }
};
```

#### 3E: METADATA UPLOAD TO IPFS
```typescript
const metadataUploadResult = await pinataService.uploadMetadata(nftMetadata);
// metadataUploadResult.url contains the tokenURI for the NFT
```

### PHASE 4: BLOCKCHAIN MINTING
**Service**: `ContextualBlockchainService`
**File**: `src/services/ContextualBlockchainService.ts`

**Smart Contract**: 
- **Address**: `0x504a0BDC3aea29237a6f8E53D0ECDA8e4c9009F2`
- **Network**: Base (Chain ID 8453)
- **Function**: `mintEvermark(string metadataURI, string title, string creator)`

**Minting Process**:
1. Get minting fee from contract
2. Prepare transaction with fee payment
3. Call contract mint function
4. Wait for transaction confirmation
5. **CRITICAL**: Extract real token ID from Transfer event logs

**Token ID Extraction (Fixed 2025-01-09)**:
```typescript
// Parse Transfer event logs to extract token ID
// Transfer event: Transfer(address indexed from, address indexed to, uint256 indexed tokenId)
const transferTopic = '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef';

const transferLog = receipt.logs?.find(log => 
  log.topics?.[0] === transferTopic && 
  log.address?.toLowerCase() === contract.address?.toLowerCase()
);

if (transferLog && transferLog.topics?.[3]) {
  // Token ID is the 3rd indexed parameter (topics[3])
  const tokenIdHex = transferLog.topics[3];
  tokenId = BigInt(tokenIdHex).toString(); // Real token ID (1, 2, 3, ...)
}
```

**Returns**:
```typescript
{
  success: true,
  txHash: "0x...",
  tokenId: "16" // Real blockchain token ID, not timestamp
}
```

### PHASE 5: DATABASE SYNCHRONIZATION
**File**: `src/features/evermarks/hooks/useEvermarkCreation.ts`
**API Endpoint**: `netlify/functions/evermarks.ts`

**Database Insert Payload**:
```typescript
{
  token_id: parseInt(mintResult.tokenId),
  tx_hash: mintResult.txHash,
  title: metadata.title,
  description: metadata.description,
  content_type: metadata.contentType,
  source_url: metadata.sourceUrl,
  token_uri: metadataUploadResult.url,
  author: castData?.author || metadata.author,
  verified: isAutoVerified,
  metadata_json: JSON.stringify({
    cast: castData ? {
      text: castData.content,
      author_username: castData.username,
      author_display_name: castData.author,
      // ... full cast metadata
    } : undefined,
    tags: metadata.tags,
    customFields: metadata.customFields
  }),
  ipfs_image_hash: imageUploadResult?.hash || null
}
```

**Database Table**: `beta_evermarks`

### PHASE 6: CAST IMAGE GENERATION
**API Endpoint**: `netlify/functions/generate-cast-image.ts`
**Triggered**: Only for Cast content type after successful database insert

**Process**:
1. Extract cast data from database metadata_json
2. Generate SVG preview image using cast text, author, engagement
3. Convert SVG to PNG using Sharp library
4. Upload to Supabase storage bucket `evermark-images`
5. Update database record with `supabase_image_url`

### PHASE 7: POINTS AWARD
**Service**: `PointsService`
**API Endpoint**: `netlify/functions/beta-points.ts`

Awards points to user for successful evermark creation.

### PHASE 8: SUCCESS RESPONSE
**Return Value**:
```typescript
{
  success: true,
  txHash: mintResult.txHash,
  tokenId: mintResult.tokenId,
  metadataURI: metadataUploadResult.url,
  imageUrl: imageUploadResult?.url || null,
  castData: castData || undefined,
  message: 'Evermark created successfully on blockchain!'
}
```

## KEY FILES AND THEIR ROLES

### Frontend Components
- `CreateEvermarkForm.tsx` - Main creation UI
- `useEvermarkState.ts` - State management for evermarks
- `useEvermarkCreation.ts` - Creation logic and blockchain interaction

### Services
- `FarcasterService.ts` - Fetch cast metadata from Farcaster
- `PinataService.ts` - IPFS uploads (images and metadata)
- `ContextualBlockchainService.ts` - Smart contract interactions
- `BlockchainService.ts` - Low-level blockchain utilities
- `PointsService.ts` - Points system integration

### API Endpoints
- `farcaster-cast.ts` - Fetch cast data from Neynar API
- `evermarks.ts` - Database CRUD operations
- `generate-cast-image.ts` - Generate cast preview images
- `beta-points.ts` - Points system

### Configuration
- `.env.local` - Contains API keys, contract addresses
- Contract address: `VITE_EVERMARK_NFT_ADDRESS`
- Supabase: `VITE_SUPABASE_URL`, `VITE_SUPABASE_ANON_KEY`
- Neynar API: `VITE_NEYNAR_API_KEY`

## COMMON FAILURE POINTS

### 1. Database Insertion Failures
**Symptoms**: Blockchain mint succeeds, but evermark doesn't appear in UI
**Causes**:
- Missing database columns (e.g., referrer_address)
- Null pointer errors (e.g., accessing imageUploadResult.hash when null)
- Network errors to database API

### 2. IPFS Upload Failures  
**Symptoms**: "Image is required" or metadata upload errors
**Causes**:
- Invalid Pinata API credentials
- Network connectivity issues
- File size/format restrictions

### 3. Cast Data Fetching Failures
**Symptoms**: Cast shows "Content will be displayed when available"
**Causes**:
- Invalid cast URLs or hashes
- Neynar API rate limits or errors
- URL parsing issues (truncated hashes)

### 4. Blockchain Transaction Failures
**Symptoms**: Transaction reverts or fails
**Causes**:
- Insufficient gas or ETH balance
- Contract paused or access restrictions
- Invalid parameters

### 5. Image Generation Failures
**Symptoms**: Cast evermarks have no images
**Causes**:
- Database insert failed (generation triggered after DB insert)
- Supabase storage permissions
- Sharp/image processing errors

## ERROR HANDLING STRATEGY

### Silent Failures (FIXED)
Previously, database sync failures were caught and ignored silently:
```typescript
} catch {
  // Don't fail if database sync fails  // BAD!
}
```

Now includes proper error logging:
```typescript
} catch (dbError) {
  console.error('❌ Database sync failed:', dbError);
  // Log but continue - mint succeeded
}
```

### Progressive Enhancement
The system is designed to work with partial failures:
1. **Blockchain mint is primary** - success here means evermark exists
2. **Database sync is secondary** - failure here means evermark won't appear in UI immediately
3. **Image generation is tertiary** - failure here means text-only evermark

## RECOVERY MECHANISMS

### Chain Sync
**File**: `src/lib/chain-sync.ts`
**Function**: `syncRecentEvermarks()`

Recovers missing evermarks by:
1. Reading recent tokens from blockchain
2. Fetching metadata from IPFS tokenURI
3. Inserting missing records into database
4. Triggering image generation if needed

### Manual Recovery
For tokens with broken metadata or sync issues:
1. Query BaseScan API for mint events
2. Extract token IDs and transaction hashes  
3. Manually fetch IPFS metadata
4. Insert database records with proper data
5. Generate missing images

## DATABASE SCHEMA

**Table**: `beta_evermarks`

**Key Fields**:
- `token_id` (integer) - On-chain token ID
- `title`, `description`, `author` - Basic metadata
- `content_type` - "Cast", "DOI", "ISBN", "URL", "Custom"
- `source_url` - Original content URL
- `token_uri` - IPFS metadata URI
- `tx_hash` - Blockchain transaction hash
- `metadata_json` - Stringified JSON with full metadata
- `ipfs_image_hash` - IPFS hash if manual image uploaded
- `supabase_image_url` - Generated image URL in Supabase storage
- `verified` - Auto-verification status
- `created_at`, `updated_at` - Timestamps

## CURRENT KNOWN ISSUES

### Token ID Generation (PARTIALLY FIXED 2025-01-09)
- **Root Cause**: `ContextualBlockchainService.ts` was using `Date.now()` as fake token ID
- **Impact**: Generated 13-digit timestamps (1,756,785,415,987) instead of real token IDs (1-15)
- **Database Error**: `"value \"1756785415987\" is out of range for type integer"`
- **Current Fix**: Using contract `totalSupply` as token ID fallback after transaction completion
- **Status**: 🚧 IN PROGRESS - Proper receipt parsing TODO, but functional with totalSupply approach

### Missing Tokens 8-11+ 
- **Status**: Exist on blockchain, not in database
- **Root Cause**: Token ID bug caused database insertion failures
- **Blockchain Token IDs**: Sequential 1, 2, 3... (small integers)
- **Database Attempted**: Large timestamps that exceeded INTEGER range
- **Recovery Needed**: Manual database insertion with correct token IDs

### Chain Sync Broken
- **Symptoms**: "401 Unauthorized" IPFS errors, BigInt serialization issues
- **Cause**: Thirdweb client authentication problems
- **Impact**: Can't automatically recover missing tokens

### Cast Image Generation Inconsistent
- **Issue**: Some Cast evermarks have images, others don't
- **Cause**: Generation depends on successful database insertion
- **Missing**: Images for tokens 8-11+ (no database records exist)

## DETAILED FAILURE ANALYSIS

### Primary Failure Point: Database Insertion *(FIXED)*
**Location**: `src/features/evermarks/hooks/useEvermarkCreation.ts:421-544`

**The Problem** *(Historical - Fixed 2025-01-09)*:
Previously, database sync failures were caught and logged but didn't stop the creation process, creating "partial success" states.

**The Fix**:
Lines 587-592 now properly throw errors when database sync fails:

```typescript
} else {
  const errorText = await dbSyncResponse.text();
  console.error('❌ Database sync response not ok:', dbSyncResponse.status, errorText);
  throw new Error(`Database sync failed: ${dbSyncResponse.status} - ${errorText}`);
}
} catch (dbError) {
  console.error('❌ Database sync failed:', dbError);
  throw new Error(`Database sync failed: ${dbError instanceof Error ? dbError.message : 'Unknown database error'}. Evermark was minted on blockchain (Token ID: ${mintResult.tokenId}, TX: ${mintResult.txHash}) but failed to sync to database. Please contact support for manual recovery.`);
}
```

**Current Behavior**:
1. ✅ Blockchain mint succeeds (user pays gas, gets NFT)
2. ❌ Database insertion fails
3. ❌ User sees clear error message with recovery details
4. ❌ Creation process fails completely (prevents orphaned tokens)

### Specific Database Errors
Based on previous debugging, the failures include:

1. **Null Pointer Errors**:
   ```
   Cannot read properties of null (reading 'hash')
   ```
   - **Location**: Line 541 - `ipfs_image_hash: imageUploadResult?.hash || null`
   - **Fixed**: Added null safety with `?.` operator

2. **Schema Mismatches**:
   ```
   Could not find the 'referrer_address' column of 'beta_evermarks'
   ```
   - **Location**: Line 542 (commented out)
   - **Status**: Field commented out pending schema update

3. **JSON Serialization Errors**:
   - Complex metadata objects may fail JSON.stringify()
   - BigInt values from blockchain can't be serialized

### Secondary Failure: Chain Sync Recovery
**Location**: `src/lib/chain-sync.ts:102-173`

**The Problem**:
The automatic recovery mechanism fails due to:

1. **Authentication Issues**:
   ```typescript
   const client = createThirdwebClient({
     clientId: getClientId()
   });
   ```
   - Environment variable access problems in Netlify Functions
   - "401 Unauthorized" errors when fetching IPFS metadata

2. **BigInt Serialization**:
   ```typescript
   const supply = await totalSupply({ contract });
   const totalSupplyNumber = Number(supply); // Can lose precision
   ```

3. **IPFS Gateway Timeouts**:
   - Pinata gateway may be slow or blocked
   - No fallback gateways configured

### Tertiary Failure: Image Generation
**Location**: `netlify/functions/generate-cast-image.ts`

**The Problem**:
Cast image generation is triggered AFTER database insertion (line 550-561):
```typescript
if (castData && mintResult.tokenId) {
  try {
    await fetch('/.netlify/functions/generate-cast-image', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ token_id: parseInt(mintResult.tokenId) })
    });
  } catch (error) {
    console.warn('Cast image generation failed:', error);
  }
}
```

If database insertion fails, the `token_id` won't exist in the database, so image generation fails.

### Error Masking Problem *(PARTIALLY FIXED)*
**Location**: Throughout creation flow

**The Problem** *(Historical)*:
Multiple layers of error handling masked the root causes.

**Current Status**:
1. **Database Failures**: ✅ FIXED - Now throws errors with recovery details
2. **Optional Image Generation**: ⚠️ Still warns but ignores (acceptable - non-critical)
3. **Success Message**: ✅ FIXED - Only shown when database sync succeeds

**Remaining Issue**: Image generation and caching failures are still non-blocking (by design).

### Recovery Challenges

1. **Missing Context**: Once creation "succeeds", we lose the original form data, cast metadata, and user intent
2. **Async Dependencies**: Image generation, points award, and cache updates depend on database records
3. **No Rollback**: Can't undo blockchain transactions, so must complete the database sync manually

### Impact Assessment

**For Tokens 8-11**:
- ✅ Exist on blockchain (permanent, correct)
- ❌ No database records (missing from UI)
- ❌ No cast images (generation never triggered)
- ❌ No points awarded (database-dependent)
- ❌ Not searchable or votable (requires database)

## RECOMMENDED FIXES

1. **Fix database insertion errors** - Handle null values properly
2. **Implement retry logic** for failed database syncs
3. **Fix chain sync authentication** issues  
4. **Add manual recovery tools** for missing tokens
5. **Improve error visibility** in UI for creation failures
6. **Add health checks** for all external dependencies (Pinata, Neynar, Supabase)

## TESTING CHECKLIST

To verify full creation flow:
1. ✅ Form submission with Cast URL
2. ✅ Cast data auto-population
3. ✅ Cast preview image generation
4. ✅ IPFS metadata upload
5. ✅ Blockchain minting
6. ✅ Database record creation
7. ✅ Cast image generation
8. ✅ Points award
9. ✅ Evermark appears in UI immediately

Current status: Steps 1-5 work, 6-9 fail for recent tokens.